"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var REQUEST_CHUNK_SIZE = 100;
var ModelCollection = /** @class */ (function () {
    function ModelCollection(modelClass, connection, path) {
        this.modelClass = modelClass;
        this.connection = connection;
        this._path = path;
        if (!this.connection) {
            throw new Error('Connection object not provided');
        }
        if (!this.modelClass) {
            throw new Error('Model class not provided');
        }
    }
    ModelCollection.prototype.forEach = function (params, eachCallback, completeCallback) {
        var _this = this;
        if (params === void 0) { params = {}; }
        if (params.view == 'count') {
            var err = new Error('forEach() cannot be called with the count view');
            if (completeCallback) {
                completeCallback(err);
            }
            throw err;
        }
        var offset = 0;
        var iteratee = function () {
            return _this.getItems(params, offset, REQUEST_CHUNK_SIZE).then(function (items) {
                for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
                    var item = items_1[_i];
                    eachCallback(item);
                }
                offset += items.length;
                var finished = items.length < REQUEST_CHUNK_SIZE;
                if (!finished) {
                    return iteratee();
                }
            });
        };
        iteratee().then(function () {
            if (completeCallback) {
                completeCallback();
            }
        }, function (err) {
            if (completeCallback) {
                return completeCallback(err);
            }
        });
    };
    ModelCollection.prototype.list = function (params, callback) {
        if (params === void 0) { params = {}; }
        if (params.view == 'count') {
            var err = new Error('list() cannot be called with the count view');
            if (callback) {
                callback(err);
            }
            return Promise.reject(err);
        }
        var limit = params.limit || Infinity;
        var offset = params.offset;
        return this.range({ params: params, offset: offset, limit: limit, callback: callback });
    };
    ModelCollection.prototype.find = function (id, paramsArg, callbackArg) {
        // callback used to be the second argument, and params was the third
        var callback;
        if (typeof callbackArg === 'function') {
            callback = callbackArg;
        }
        else if (typeof paramsArg === 'function') {
            callback = paramsArg;
        }
        var params = {};
        if (paramsArg && typeof paramsArg === 'object') {
            params = paramsArg;
        }
        else if (callbackArg && typeof callbackArg === 'object') {
            params = callbackArg;
        }
        if (!id) {
            var err = new Error('find() must be called with an item id');
            if (callback) {
                callback(err);
            }
            return Promise.reject(err);
        }
        if (params.view == 'count' || params.view == 'ids') {
            var err = new Error('find() cannot be called with the count or ids view');
            if (callback) {
                callback(err);
            }
            return Promise.reject(err);
        }
        return this.getModel(id, params)
            .then(function (model) {
            if (callback) {
                callback(null, model);
            }
            return Promise.resolve(model);
        })
            .catch(function (err) {
            if (callback) {
                callback(err);
            }
            return Promise.reject(err);
        });
    };
    ModelCollection.prototype.path = function () {
        return this._path;
    };
    ModelCollection.prototype.range = function (_a) {
        var _this = this;
        var _b = _a.params, params = _b === void 0 ? {} : _b, _c = _a.offset, offset = _c === void 0 ? 0 : _c, _d = _a.limit, limit = _d === void 0 ? 100 : _d, callback = _a.callback, path = _a.path;
        var accumulated = [];
        var iteratee = function () {
            var chunkOffset = offset + accumulated.length;
            var chunkLimit = Math.min(REQUEST_CHUNK_SIZE, limit - accumulated.length);
            return _this.getItems(params, chunkOffset, chunkLimit, path).then(function (items) {
                accumulated = accumulated.concat(items);
                var finished = items.length < REQUEST_CHUNK_SIZE || accumulated.length >= limit;
                if (!finished) {
                    return iteratee();
                }
            });
        };
        // do not return rejected promise when callback is provided
        // to prevent unhandled rejection warning
        return iteratee().then(function () {
            if (callback) {
                callback(null, accumulated);
            }
            return accumulated;
        }, function (err) {
            if (callback) {
                callback(err);
            }
            throw err;
        });
    };
    ModelCollection.prototype.getItems = function (params, offset, limit, path) {
        // Items can be either models or ids
        if (!path) {
            path = this.path();
        }
        if (params.view == 'ids') {
            return this.connection.request({
                method: 'GET',
                path: path,
                qs: __assign(__assign({}, params), { offset: offset, limit: limit }),
                baseUrl: this.baseUrl,
            });
        }
        return this.getModelCollection(params, offset, limit, path);
    };
    ModelCollection.prototype.createModel = function (json) {
        return new this.modelClass().fromJSON(json);
    };
    ModelCollection.prototype.getModel = function (id, params) {
        var _this = this;
        if (params === void 0) { params = {}; }
        return this.connection
            .request({
            method: 'GET',
            path: this.path() + "/" + id,
            qs: params,
            baseUrl: this.baseUrl,
        })
            .then(function (json) {
            var model = _this.createModel(json);
            return Promise.resolve(model);
        });
    };
    ModelCollection.prototype.getModelCollection = function (params, offset, limit, path) {
        var _this = this;
        return this.connection
            .request({
            method: 'GET',
            path: path,
            qs: __assign(__assign({}, params), { offset: offset, limit: limit }),
            baseUrl: this.baseUrl,
        })
            .then(function (jsonArray) {
            var models = jsonArray.map(function (json) {
                return _this.createModel(json);
            });
            return Promise.resolve(models);
        });
    };
    return ModelCollection;
}());
exports.default = ModelCollection;
