"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var nylas_connection_1 = require("../nylas-connection");
var outbox_job_status_1 = __importDefault(require("./outbox-job-status"));
var model_1 = __importDefault(require("./model"));
var attributes_1 = __importDefault(require("./attributes"));
var SendGridVerifiedStatus = /** @class */ (function (_super) {
    __extends(SendGridVerifiedStatus, _super);
    function SendGridVerifiedStatus() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SendGridVerifiedStatus.attributes = {
        domainVerified: attributes_1.default.Boolean({
            modelKey: 'domainVerified',
            jsonKey: 'domain_verified',
        }),
        senderVerified: attributes_1.default.Boolean({
            modelKey: 'senderVerified',
            jsonKey: 'sender_verified',
        }),
    };
    return SendGridVerifiedStatus;
}(model_1.default));
exports.SendGridVerifiedStatus = SendGridVerifiedStatus;
var Outbox = /** @class */ (function () {
    function Outbox(connection) {
        this.path = '/v2/outbox';
        this.connection = connection;
    }
    Outbox.prototype.send = function (draft, options) {
        var _this = this;
        var body = draft.saveRequestBody();
        if (options.tracking) {
            body['tracking'] = options.tracking;
        }
        var _a = Outbox.validateAndFormatDateTime(options.sendAt, options.retryLimitDatetime), sendAt = _a[0], retryLimitDatetime = _a[1];
        body['send_at'] = sendAt;
        body['retry_limit_datetime'] = retryLimitDatetime;
        return this.request({
            method: 'POST',
            path: '',
            body: body,
        })
            .then(function (json) {
            var message = new outbox_job_status_1.default(_this.connection).fromJSON(json);
            if (options.callback) {
                options.callback(null, message);
            }
            return Promise.resolve(message);
        })
            .catch(function (err) {
            if (options.callback) {
                options.callback(err);
            }
            return Promise.reject(err);
        });
    };
    Outbox.prototype.update = function (jobStatusId, options) {
        var _this = this;
        var body = {};
        if (options.updatedMessage) {
            body = options.updatedMessage.saveRequestBody();
        }
        var _a = Outbox.validateAndFormatDateTime(options.sendAt, options.retryLimitDatetime), sendAt = _a[0], retryLimitDatetime = _a[1];
        body['send_at'] = sendAt;
        body['retry_limit_datetime'] = retryLimitDatetime;
        return this.request({
            method: 'PATCH',
            path: "/" + jobStatusId,
            body: body,
        }).then(function (json) {
            var message = new outbox_job_status_1.default(_this.connection).fromJSON(json);
            return Promise.resolve(message);
        });
    };
    Outbox.prototype.delete = function (jobStatusId) {
        return this.request({
            method: 'DELETE',
            path: "/" + jobStatusId,
        });
    };
    Outbox.prototype.sendGridVerificationStatus = function () {
        return this.request({
            method: 'GET',
            path: "/onboard/verified_status",
        }).then(function (json) {
            if (json.results) {
                json = json.results;
            }
            var verifiedStatus = new SendGridVerifiedStatus().fromJSON(json);
            return Promise.resolve(verifiedStatus);
        });
    };
    Outbox.prototype.deleteSendGridSubUser = function (email) {
        return this.request({
            method: 'DELETE',
            path: "/onboard/subuser",
            body: { email: email },
        });
    };
    Outbox.prototype.request = function (options) {
        var header;
        if (options.body) {
            header = {
                'Content-Type': 'application/json',
            };
        }
        return this.connection.request({
            method: options.method,
            path: "" + this.path + options.path,
            body: options.body,
            headers: header,
            authMethod: nylas_connection_1.AuthMethod.BEARER,
        });
    };
    Outbox.validateAndFormatDateTime = function (sendAt, retryLimitDatetime) {
        var sendAtEpoch = sendAt instanceof Date ? Outbox.dateToEpoch(sendAt) : sendAt;
        var retryLimitDatetimeEpoch = retryLimitDatetime instanceof Date
            ? Outbox.dateToEpoch(retryLimitDatetime)
            : retryLimitDatetime;
        if (sendAtEpoch && sendAtEpoch !== 0) {
            if (sendAtEpoch < Outbox.dateToEpoch(new Date())) {
                throw new Error('Cannot set message to be sent at a time before the current time.');
            }
        }
        if (retryLimitDatetimeEpoch && retryLimitDatetimeEpoch !== 0) {
            var validSendAt = sendAtEpoch;
            if (!validSendAt || validSendAt === 0) {
                validSendAt = Outbox.dateToEpoch(new Date());
            }
            if (retryLimitDatetimeEpoch < validSendAt) {
                throw new Error('Cannot set message to stop retrying before time to send at.');
            }
        }
        return [sendAtEpoch, retryLimitDatetimeEpoch];
    };
    Outbox.dateToEpoch = function (date) {
        return Math.floor(date.getTime() / 1000.0);
    };
    return Outbox;
}());
exports.default = Outbox;
